- 형상 관리 시스템은 왜 나오게 되었을까요?

  저번 주에 내가 잘 완성해놓은 프로젝트에 누군가 수정 작업을 했는데 그 누군가가 정말 궁금해지는 경우가 있습니다. 또는, 1시간 전까지 잘 작동하던 코드에 이것저것 수정하다보니 컴파일이 되지 않아 되돌리고 싶은 경우가 있습니다.

  소프트웨어 공학에는 형상 관리(Software Configuration Management)라 불리는 개념이 있습니다. 형상 관리를 도입하면 소프트웨어의 변경 사항을 추적하고 통제할 수 있습니다. 즉, **파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는**겁니다. 우리는 형상 관리 시스템을 이용해 시간에 따라 비교하며, 작업 사항(누가 이 프로젝트를 망쳐놨는지)을 추적하고, 소프트웨어를 특정 시점(저번 주)의 상태로 되돌릴 수 있습니다. 이런 이유 때문에 형상 관리는 비단 소프트웨어 뿐만 아니라 여러 분야에서 쓰이고 있습니다.

- git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?

  git은 DVCS(분산 버전 관리 시스템, 형상 관리는 버전 관리를 학술적으로 포괄하는 용어)입니다. 분산되었다는 말은 버전 히스토리가 어느 특정 서버에 귀속된 것이 아니라, 프로젝트에 속한 클라이언트, 즉 작업하는 사람에게 복제되어 있다는 말과 동일합니다. 클라이언트는 프로젝트를 checkout할 때 파일의 마지막 스냅샷과 히스토리를 전부 복제합니다. 이 말인즉슨 버전이 관리되고 있는 데이터베이스가 있는 서버(리모트 저장소)에 문제가 생겨도 클라이언트에 저장된 복제물로 백업이 가능하단 것입니다.

  git은 프로젝트의 버전을 스냅샷으로 관리합니다. 이전과 비교해 변경되지 않은 파일은 링크만 저장합니다. 또한 git은 SHA-1 해시를 사용하여 만든 체크섬으로 모든 것을 식별합니다.

  - git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?

    git은 Linux 커널에서 쓰이던 상용 DVCS인 BitKeeper의 무료 사용이 중단되면서 만들어지게 되었습니다. git이 분산형 시스템을 채택한 이유는 아마 Linux가 굉장히 규모가 큰 오픈소스 프로젝트이고 그렇기 때문에 비선형적인 개발 환경(동시다발적인 작업과 히스토리 관리)이 필요해서이지 않을까 싶습니다.

- git과 GitHub은 어떻게 다를까요?

  git은 앞서 말한 버전 관리 시스템이고, GitHub은 이 git을 온라인으로 호스팅하는 서비스입니다. GitHub을 통해서 다른 개발자와 공동 작업이 가능합니다(물론 GitHub이 아닌 GitLab과 같은 다른 git 저장소 호스트를 이용할 수 있습니다).

- git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?

  - git clone \<url\>

    - 다른 프로젝트에 기여(contribute)하거나 git 저장소를 복사하고 싶을 때 사용하는 명령어입니다.
    - 서버에 있는 모든 데이터(프로젝트 히스토리 포함)를 복사합니다.
    - `https://` 프로토콜, `git://` 프로토콜, SSH 프로토콜을 사용해 git 저장소에 접근 가능합니다.

  - git add (files)

    - git 저장소에 포함되지 않은(Untracked) 파일을 반영하기 위해 새로 추적하도록 스테이징(staging)합니다.
    - 이미 Tracked 상태인 파일이 수정되었을 때 git 저장소에 반영하기 위해 스테이징(staging)합니다.

  - git commit

    - Staged 상태인 파일들을 버저닝(versioning)하기 위해 커밋합니다.
    - 명령 실행 후 편집기에서 커밋 메시지를 남기거나 `git commit -m 'type commit message here'`와 같이 인라인으로도 작성 가능합니다.
    - `git commit -a` 명령은 `git add` 명령 없이 Staging Area를 생략하고 커밋합니다.
    - `git commit --amend`는 마지막 커밋을 덮어쓰는 커밋 명령입니다.

  - git push

    - 로컬 저장소의 브랜치를 리모트 저장소에 전송하는 명령입니다.
    - `git push origin serverfix` 명령은 로컬의 serverfix 브랜치를 리모트 저장소의 serverfix 브랜치로 push하라는 의미입니다.
    -

  - git pull

    - 추적 브랜치를 설정한 후 서버로부터 데이터를 가져와서 현재 로컬 브랜치와 서버의 추적 브랜치를 merge하는 명령입니다.
    - `git fetch` + `git merge`와 동일합니다.
    - `git fetch`는 서버(리모트 저장소)에서 데이터를 가져와 로컬의 리모트 브랜치 정보를 업데이트합니다.

  - git branch

    - 아무런 옵션이 없으면 브랜치의 목록을 조회합니다.

      - `*`가 붙어있는 브랜치는 현재 checkout해서 작업 중인 브랜치입니다.
      - `-v` 옵션을 붙이면 각 브랜치별 마지막 커밋을 보여줍니다.
      - `git branch <name>` 명령은 해당 이름으로 새로운 브랜치를 생성합니다.

    - `git branch -d <branch>` 명령은 브랜치 삭제합니다(merge하지 않은 브랜치는 삭제되지 않습니다).
    - `git branch -D <branch>`는 해당 브랜치를 강제 삭제합니다.
    - `git checkout -b <branch> <remote>/<branch>` 명령은 리모트 브랜치와 연결된 새로운 트래킹 브랜치를 생성합니다(로컬 브랜치에 해당 이름으로 된 브랜치가 없다면 리모트 브랜치 옵션을 생략 가능합니다).

  - git stash

    - 만약 어떤 브랜치에서 작업하고 있는데 다른 브랜치에서 할 일이 생기면 작업하던 사항을 저장한 뒤 다른 브랜치로 이동(checkout)해야 합니다.
    - 아직 커밋하지 않은 파일이 checkout할 브랜치와 충돌나면 브랜치를 변경할 수 없습니다.
    - 아직 완료하지 않은 일을 커밋하는 것이 찝찝할 수 있습니다.
    - stash 기능을 사용해 작업사항을 git 내부 스택에 저장할 수 있습니다.
    - `git stash` 명령을 사용하면 작업하던 내용(modified이면서 tracked 상태인 파일과 staging area에 있는 파일)을 보관해줍니다.
    - `git stash -u` 명령은 untracked 파일까지 저장해줍니다.
    - `git stash list` 명령을 사용하면 보관 중인 stash들을 확인할 수 있습니다.
    - `git stash apply <stash@{stash_number}>` 명령을 사용해 stash를 다시 적용할 수 있습니다. stash를 지정하지 않을 경우 가장 최근의 stash를 적용합니다.
    - `git stash drop stash@{stash_number}` 명령을 사용해 적용한 stash를 제거합니다.
    - `git stash pop` 명령은 `git stash apply && git stash drop` 명령과 동일합니다.
    - `git stash branch <branch>` 명령은 stash할 당시의 커밋을 새로운 브랜치를 만들어 checkout한 후 해당 stash를 바로 적용합니다. 성공할 경우 stash를 삭제합니다.

- git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?

  - [Object](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)

    - git은 key-value 데이터 저장소입니다.
    - 어떤 형식의 데이터라도 집어넣을 수 있고 해당 key로 언제든지 데이터를 다시 조회합니다.
    - git object 관련해서 트리 개체, 커밋 개체, 개체 저장소라는 개념이 있습니다.

  - Commit

    - Staging Area에 있는 데이터의 스냅샷에 대한 포인터, 저자나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 객체입니다.
    - 최초 커밋 외 나머지 커밋은 이전 커밋 포인터가 적어도 하나 이상 존재합니다.
    - 브랜치를 합친 Merge 커밋은 이전 커밋 포인터가 여러 개 존재합니다.

  - Head

    - 현재 작업 중인 로컬 브랜치를 가리키는 포인터입니다.

  - Branch

    - 브랜치는 같은 코드를 통째로 복사해서 원래 코드와 상관없이 독립적으로 개발할 수 있도록 해주는 환경입니다.
    - git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일입니다.
    - **일종의 커밋 사이를 이동할 수 있는 포인터**입니다.
    - git은 기본 브랜치를 `main`으로 생성합니다.
    - 브랜치를 만들어 작업하고 나중에 merge하는 방식이 바로 git의 버전관리 철학입니다.
    - 커밋은 이전 커밋의 정보를 저장하기 때문에 merge할 때 어디서부터(merge base) 합쳐야 하는지 알 수 있습니다.
    - 브랜치를 이동할 경우 아직 커밋하지 않은 파일이 checkout할 브랜치와 conflict가 발생하면 브랜치 변경이 불가합니다.

  - Tag

    - 태그는 특정 커밋에 포인터(태그)를 붙여서 따로 조회하는 기능입니다.
    - 보통 릴리즈할 때 사용합니다.
    - `git tag`로 기존 태그 목록을 조회할 수 있습니다.
    - Lightweight 태그

      - 단순히 특정 커밋에 대한 포인터입니다.

    - Annotated 태그

      - Lightweight 태그보다 정보가 많은 태그입니다.
      - git 데이터베이스에 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜, 태그 메시지 등을 저장합니다.
      - GPG(GNU Privacy Guard)로 서명 가능합니다.

  - git이 데이터를 저장하는 방법

    - 데이터를 변경사항으로 기록하는 것이 아니라 일련의 스냅샷으로 기록합니다.
    - 파일이 달라지지 않았다면 파일을 새로 저장하는 것이 아니라 이전 상태의 파일에 대한 링크만 저장합니다.
    - 즉, git으로 무얼 하든 git 데이터베이스에 *추가*됩니다. 스냅샷을 커밋하면 데이터를 잃어버리기 어렵습니다.
    - commit하지 않으면 변경사항을 잃어버릴 수 있습니다.

  - 두 브랜치를 merge하는 방법

    - fast-forward
    - 3-way merge(recursive)
    - conflict(merge 실패)

  - 완료한 커밋을 수정하는 방법

    - `git commit --amend` 명령을 사용합니다.
    - 파일 수정 작업을 하고 싶든, 커밋 메시지만 수정하고 싶다면 해당 명령을 사용합니다.
    - 해당 명령으로 기록한 커밋은 기존 커밋을 덮어씁니다.
    - 해당 명령의 장점은 마지막 커밋 작업에서 사소한 작업을 놓쳤을 경우 새로운 커밋을 만들지 않고 수정 가능하단 점에서 유용합니다.

  - 파일 상태를 Unstage로 변경하는 방법

    - `git reset HEAD <file>` 명령은 실수로 `git add .` 명령을 통해 Staging Area에 올린 파일을 Unstaging합니다.

  - Modified 파일 되돌리는 방법

    - 수정한 뒤 Staging Area로 올린 파일을 수정되기 전의 상태로 되돌리는 명령은 `git checkout -- <file>`입니다.
    - 원래 파일로 덮어쓰기 때문에 수정한 내용은 전부 사라집니다.

- 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?

  1. 이런 상황은 자주 발생하지 않아야겠지만, 어쩔 수 없을 경우 우선 해당 remote repository에서 협업 중인 팀원들에게 이슈를 전파합니다.
  2. 원하지 않는 파일을 소유하고 있는 모든 로컬 저장소에서 `git rm --cached <file>` 명령을 사용해 git이 원하지 않는 파일을 추적하지 않도록 설정합니다(폴더를 추적 중지시키려면 `git rm -r --cached <folder>`).
  3. `git add . && git commit -m 'remove unwanted files'` 명령 등을 통해 수정사항을 커밋합니다.
  4. `git push` 명령을 통해 리모트 저장소에 반영합니다.
